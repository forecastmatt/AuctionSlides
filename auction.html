<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auction Slides</title>
<style>
  /* ── Reset ── */
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #1a1a2e;
    color: #eee;
    min-height: 100vh;
  }

  /* ── CONTROL DECK (setup screen) ── */
  #controlDeck {
    max-width: 900px;
    margin: 0 auto;
    padding: 30px 20px;
  }

  #controlDeck h1 {
    text-align: center;
    font-size: 1.8rem;
    margin-bottom: 6px;
    color: #e2b04a;
  }
  #controlDeck .subtitle {
    text-align: center;
    color: #888;
    margin-bottom: 28px;
    font-size: 0.9rem;
  }

  /* ── Tab Bar ── */
  .tab-bar {
    display: flex;
    align-items: center;
    gap: 0;
    margin-bottom: 20px;
    border-bottom: 2px solid #333;
    overflow-x: auto;
    scrollbar-width: thin;
  }
  .tab-bar .tab {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 10px 18px;
    background: #16213e;
    border: 1px solid #333;
    border-bottom: none;
    border-radius: 8px 8px 0 0;
    color: #aaa;
    font-size: 0.9rem;
    cursor: pointer;
    white-space: nowrap;
    position: relative;
    user-select: none;
    transition: background 0.15s, color 0.15s;
  }
  .tab-bar .tab:hover { background: #1e2d50; }
  .tab-bar .tab.active {
    background: #1a1a2e;
    color: #e2b04a;
    border-color: #e2b04a;
    font-weight: 600;
  }
  .tab-bar .tab .tab-close {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: none;
    border: none;
    color: #666;
    font-size: 0.8rem;
    cursor: pointer;
    line-height: 1;
    padding: 0;
  }
  .tab-bar .tab .tab-close:hover { background: rgba(192,57,43,0.3); color: #e74c3c; }
  .tab-bar .tab-add {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    background: none;
    border: 1px dashed #555;
    border-bottom: none;
    border-radius: 8px 8px 0 0;
    color: #888;
    font-size: 1.2rem;
    cursor: pointer;
    flex-shrink: 0;
    transition: color 0.15s, border-color 0.15s;
  }
  .tab-bar .tab-add:hover { color: #e2b04a; border-color: #e2b04a; }

  /* ── Settings row ── */
  .settings-row {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    align-items: flex-end;
    margin-bottom: 24px;
  }
  .settings-row label {
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-size: 0.85rem;
    color: #aaa;
  }
  .settings-row select,
  .settings-row input[type="text"],
  .settings-row input[type="number"] {
    padding: 8px 12px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #16213e;
    color: #eee;
    font-size: 1rem;
    width: 160px;
  }

  /* ── Header text setting ── */
  .settings-row input.wide { width: 300px; }

  /* ── Drop zone ── */
  #dropZone {
    border: 2px dashed #444;
    border-radius: 12px;
    padding: 50px 20px;
    text-align: center;
    color: #777;
    font-size: 1rem;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    margin-bottom: 24px;
    position: relative;
  }
  #dropZone.dragover {
    border-color: #e2b04a;
    background: rgba(226, 176, 74, 0.06);
  }
  #dropZone input[type="file"] {
    position: absolute;
    inset: 0;
    opacity: 0;
    cursor: pointer;
  }

  /* ── Section headings ── */
  .section-heading {
    font-size: 0.95rem;
    color: #e2b04a;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #333;
  }

  /* ── Queue list ── */
  #queueList {
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 16px;
  }
  #queueList li {
    display: flex;
    align-items: center;
    gap: 12px;
    background: #16213e;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 10px 14px;
    cursor: grab;
  }
  #queueList li.dragging {
    opacity: 0.4;
  }
  #queueList li .thumb {
    width: 64px;
    height: 44px;
    object-fit: cover;
    border-radius: 4px;
    background: #000;
    flex-shrink: 0;
  }
  #queueList li .file-name {
    flex: 1;
    font-size: 0.9rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  #queueList li .file-type {
    font-size: 0.75rem;
    padding: 2px 8px;
    border-radius: 4px;
    text-transform: uppercase;
  }
  .file-type.image { background: #1b4332; color: #95d5b2; }
  .file-type.video { background: #3c1642; color: #d4a5e5; }

  #queueList li .timer-input {
    width: 60px;
    padding: 6px 8px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #0f3460;
    color: #eee;
    font-size: 0.9rem;
    text-align: center;
  }
  #queueList li .timer-label {
    font-size: 0.75rem;
    color: #888;
    white-space: nowrap;
  }
  #queueList li .use-full-length {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.75rem;
    color: #888;
    white-space: nowrap;
  }

  #queueList li .remove-btn {
    background: none;
    border: none;
    color: #c0392b;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0 4px;
    line-height: 1;
  }

  /* ── Buttons ── */
  .btn-row {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
    margin-bottom: 32px;
  }
  .btn {
    padding: 12px 28px;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s;
  }
  .btn-primary {
    background: #e2b04a;
    color: #1a1a2e;
  }
  .btn-primary:hover { background: #d4a03a; }
  .btn-primary:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
  .btn-secondary {
    background: #333;
    color: #eee;
  }
  .btn-secondary:hover { background: #444; }

  .empty-msg {
    text-align: center;
    color: #555;
    padding: 20px;
    font-size: 0.9rem;
  }

  /* ── PRESENTATION (fullscreen display) ── */
  #presentation {
    display: none;
    position: fixed;
    inset: 0;
    background: #000;
    z-index: 9999;
    overflow: hidden;
  }

  /* ── Sticky header overlay ── */
  #headerOverlay {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 10;
    background: rgb(0,80,0);
    padding: 20px 30px;
    text-align: center;
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    transition: opacity 1s ease;
  }
  #headerOverlay .header-text {
    font-size: 2.6rem;
    font-weight: 700;
    color: #e2b04a;
    text-shadow: 0 2px 8px rgba(0,0,0,0.6);
    margin-bottom: 2px;
  }
  #headerOverlay .countdown {
    font-size: 4rem;
    font-weight: 700;
    color: #fff;
    font-variant-numeric: tabular-nums;
    text-shadow: 0 2px 12px rgba(0,0,0,0.8);
    letter-spacing: 2px;
  }
  #headerOverlay .countdown.done {
    color: #27ae60;
    font-size: 3.6rem;
  }

  /* ── Fullscreen takeover when countdown ends ── */
  #headerOverlay.takeover {
    inset: 0;
    top: 0;
    left: 0;
    border-radius: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }
  #headerOverlay.takeover .countdown.done {
    font-size: 12vw;
    line-height: 1.1;
    padding: 0 5vw;
    word-break: break-word;
  }

  /* ── Media stage ── */
  #stage {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #stage img, #stage video {
    width: 100%;
    height: 100%;
    object-fit: contain;
    transition: opacity 0.8s ease;
    opacity: 0;
  }
  #stage img.visible, #stage video.visible {
    opacity: 1;
  }

  /* ── Exit button (small, top-right) ── */
  #exitBtn {
    position: absolute;
    top: 12px;
    right: 16px;
    z-index: 20;
    background: rgba(255,255,255,0.1);
    border: none;
    color: #aaa;
    font-size: 0.8rem;
    padding: 6px 14px;
    border-radius: 6px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.3s;
  }
  #presentation:hover #exitBtn { opacity: 1; }

  /* ── Cloud Sync ── */
  .cloud-section {
    margin-bottom: 24px;
    padding: 16px;
    border: 1px solid #333;
    border-radius: 8px;
    background: #16213e;
  }
  .cloud-section h3 {
    font-size: 0.95rem;
    color: #e2b04a;
    margin-bottom: 12px;
  }
  .cloud-row {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }
  .cloud-row:last-child { margin-bottom: 0; }
  .cloud-status {
    font-size: 0.85rem;
    color: #888;
  }
  .cloud-status.syncing { color: #e2b04a; }
  .cloud-status.done { color: #27ae60; }
  .cloud-status.error { color: #e74c3c; }
  .cloud-link {
    font-size: 0.85rem;
    color: #5dade2;
    word-break: break-all;
    cursor: pointer;
    text-decoration: underline;
  }
  .btn-small {
    padding: 6px 14px;
    border: none;
    border-radius: 6px;
    font-size: 0.85rem;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s;
  }
  .btn-cloud {
    background: #2980b9;
    color: #fff;
  }
  .btn-cloud:hover { background: #3498db; }
  .btn-cloud:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-danger-small {
    background: #c0392b;
    color: #fff;
  }
  .btn-danger-small:hover { background: #e74c3c; }

  /* ── Loop toggle ── */
  .loop-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.85rem;
    color: #aaa;
  }

</style>
</head>
<body>

<!-- ════════════════════════════════════════════════ -->
<!-- CONTROL DECK                                     -->
<!-- ════════════════════════════════════════════════ -->
<div id="controlDeck">
  <h1>Auction Slides</h1>
  <p class="subtitle">Upload media, set your times, and project.</p>

  <!-- Tab Bar -->
  <div class="tab-bar" id="tabBar"></div>

  <!-- Settings -->
  <div class="settings-row">
    <label>
      Header Text
      <input type="text" id="headerText" class="wide" placeholder="e.g. Auction Starting In" value="Auction Starting In">
    </label>
    <label>
      Auction Date
      <input type="date" id="startDate">
    </label>
    <label>
      Hour
      <select id="startHour">
        <option value="">--</option>
        <option value="1">1</option><option value="2">2</option><option value="3">3</option>
        <option value="4">4</option><option value="5">5</option><option value="6">6</option>
        <option value="7" selected>7</option><option value="8">8</option><option value="9">9</option>
        <option value="10">10</option><option value="11">11</option><option value="12">12</option>
      </select>
    </label>
    <label>
      Min
      <select id="startMinute">
        <option value="00" selected>00</option><option value="05">05</option>
        <option value="10">10</option><option value="15">15</option>
        <option value="20">20</option><option value="25">25</option>
        <option value="30">30</option><option value="35">35</option>
        <option value="40">40</option><option value="45">45</option>
        <option value="50">50</option><option value="55">55</option>
      </select>
    </label>
    <label>
      AM/PM
      <select id="startPeriod">
        <option value="AM">AM</option>
        <option value="PM" selected>PM</option>
      </select>
    </label>
    <label>
      Default Seconds (images)
      <input type="number" id="defaultSeconds" value="10" min="1" max="300">
    </label>
    <label>
      Countdown End Text
      <input type="text" id="countdownEndText" class="wide" placeholder="e.g. Bidding is LIVE!" value="Bidding is LIVE!">
    </label>
  </div>

  <!-- Live countdown preview on control deck -->
  <div id="countdownPreview" style="text-align:center; margin-bottom:20px; font-size:1.4rem; color:#e2b04a; font-variant-numeric:tabular-nums;"></div>

  <div class="settings-row">
    <label class="loop-toggle">
      <input type="checkbox" id="loopQueue" checked>
      Loop slideshow until auction starts
    </label>
  </div>

  <!-- Drop Zone -->
  <div id="dropZone">
    Drag &amp; drop photos and videos here, or click to browse
    <input type="file" id="fileInput" multiple accept="image/*,video/*">
  </div>

  <!-- Queue -->
  <h3 class="section-heading">Slides <span id="totalDuration" style="float:right; font-weight:400; font-size:0.85rem; color:#888;"></span></h3>
  <ul id="queueList"></ul>
  <p class="empty-msg" id="emptyMsg">No files yet. Drop some above.</p>

  <!-- Actions -->
  <div class="btn-row">
    <button class="btn btn-primary" id="goBtn" disabled>Go Fullscreen</button>
    <button class="btn btn-secondary" id="clearBtn">Clear All</button>
    <button class="btn btn-secondary" id="exportBtn">Export Slideshow</button>
    <button class="btn btn-secondary" id="importBtn">Import Slideshow</button>
  </div>
  <input type="file" id="importFileInput" accept=".json" style="display:none">

  <!-- Cloud Sync -->
  <div class="cloud-section">
    <h3>Cloud Sync</h3>
    <div class="cloud-row">
      <button class="btn-small btn-cloud" id="cloudSaveBtn">Save to Cloud</button>
      <button class="btn-small btn-cloud" id="cloudLoadBtn" style="display:none">Reload from Cloud</button>
      <span class="cloud-status" id="cloudStatus">Ready</span>
    </div>
    <div class="cloud-row" id="cloudLinkRow" style="display:none">
      <span class="cloud-link" id="cloudLink"></span>
      <button class="btn-small btn-cloud" id="copyLinkBtn">Copy Link</button>
    </div>
  </div>

</div>

<!-- ════════════════════════════════════════════════ -->
<!-- PRESENTATION                                     -->
<!-- ════════════════════════════════════════════════ -->
<div id="presentation">
  <div id="headerOverlay">
    <div class="header-text" id="liveHeaderText"></div>
    <div class="countdown" id="liveCountdown"></div>
  </div>
  <div id="stage"></div>
  <button id="exitBtn">ESC &mdash; Exit</button>
</div>

<script>
// ── Multi-Slideshow State ──
let slideshows = []; // [{ id, name, queue:[], settings:{} }]
let activeSlideshowIndex = 0;
let nextSlideshowId = 1;

let countdownInterval = null;
let slideshowTimeout = null;
let currentIndex = 0;
let running = false;
let wakeLock = null;

function defaultSettings() {
  const today = new Date();
  const todayStr = today.getFullYear() + '-' +
    String(today.getMonth() + 1).padStart(2, '0') + '-' +
    String(today.getDate()).padStart(2, '0');
  return {
    headerText: 'Auction Starting In',
    startDate: todayStr,
    startHour: '7',
    startMinute: '00',
    startPeriod: 'PM',
    defaultSeconds: '10',
    loopQueue: true,
    countdownEndText: 'Bidding is LIVE!',
  };
}

function createSlideshow(name) {
  const s = {
    id: nextSlideshowId++,
    name: name,
    queue: [],
    settings: defaultSettings(),
  };
  slideshows.push(s);
  return s;
}

function getActiveSlideshow() {
  return slideshows[activeSlideshowIndex];
}

// Save current UI state into the active slideshow's settings
function saveUIToActiveSlideshow() {
  const s = getActiveSlideshow();
  if (!s) return;
  s.settings.headerText = headerTextIn.value;
  s.settings.startDate = document.getElementById('startDate').value;
  s.settings.startHour = document.getElementById('startHour').value;
  s.settings.startMinute = document.getElementById('startMinute').value;
  s.settings.startPeriod = document.getElementById('startPeriod').value;
  s.settings.defaultSeconds = defaultSecIn.value;
  s.settings.loopQueue = loopCheckbox.checked;
  s.settings.countdownEndText = countdownEndTextIn.value;
}

// Load a slideshow's settings into the UI
function loadSlideshowToUI(s) {
  headerTextIn.value = s.settings.headerText;
  if (!s.settings.startDate) {
    const t = new Date();
    s.settings.startDate = t.getFullYear() + '-' +
      String(t.getMonth() + 1).padStart(2, '0') + '-' +
      String(t.getDate()).padStart(2, '0');
  }
  document.getElementById('startDate').value = s.settings.startDate;
  document.getElementById('startHour').value = s.settings.startHour;
  document.getElementById('startMinute').value = s.settings.startMinute;
  document.getElementById('startPeriod').value = s.settings.startPeriod;
  defaultSecIn.value = s.settings.defaultSeconds;
  loopCheckbox.checked = s.settings.loopQueue;
  countdownEndTextIn.value = s.settings.countdownEndText;
}

function switchSlideshow(index) {
  if (index === activeSlideshowIndex && slideshows.length > 0) return;
  saveUIToActiveSlideshow();
  activeSlideshowIndex = index;
  const s = getActiveSlideshow();
  loadSlideshowToUI(s);
  renderQueue();
  renderTabs();
  saveToDB();
}

function deleteSlideshow(index) {
  if (slideshows.length <= 1) { alert('Cannot delete the only slideshow.'); return; }
  if (!confirm(`Delete "${slideshows[index].name}"? This cannot be undone.`)) return;
  // Revoke object URLs
  slideshows[index].queue.forEach(item => URL.revokeObjectURL(item.objectURL));
  slideshows.splice(index, 1);
  if (activeSlideshowIndex >= slideshows.length) activeSlideshowIndex = slideshows.length - 1;
  else if (index < activeSlideshowIndex) activeSlideshowIndex--;
  const s = getActiveSlideshow();
  loadSlideshowToUI(s);
  renderQueue();
  renderTabs();
  saveToDB();
}

// ── IndexedDB persistence ──
const DB_NAME = 'AuctionSlidesDB';
const DB_VERSION = 2;
const STORE_NAME = 'media';
const SETTINGS_STORE = 'settings';
const SLIDESHOWS_STORE = 'slideshows_meta';

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      // v1 stores
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
      }
      if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
        db.createObjectStore(SETTINGS_STORE, { keyPath: 'key' });
      }
      // v2: new store for multi-slideshow metadata
      if (!db.objectStoreNames.contains(SLIDESHOWS_STORE)) {
        db.createObjectStore(SLIDESHOWS_STORE, { keyPath: 'key' });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function saveToDB() {
  saveUIToActiveSlideshow();
  const db = await openDB();
  const tx = db.transaction([STORE_NAME, SETTINGS_STORE, SLIDESHOWS_STORE], 'readwrite');
  const mediaStore = tx.objectStore(STORE_NAME);
  const settingsStore = tx.objectStore(SETTINGS_STORE);
  const metaStore = tx.objectStore(SLIDESHOWS_STORE);

  // Clear old stores
  mediaStore.clear();
  settingsStore.clear();
  metaStore.clear();

  // Save slideshow metadata (without queue blobs)
  const metaList = slideshows.map((s, idx) => ({
    id: s.id,
    name: s.name,
    settings: s.settings,
    queueLength: s.queue.length,
  }));
  metaStore.put({ key: 'slideshows', value: metaList });
  metaStore.put({ key: 'activeSlideshowIndex', value: activeSlideshowIndex });
  metaStore.put({ key: 'nextSlideshowId', value: nextSlideshowId });

  // Save all media across all slideshows, keyed by slideshowId + index
  let globalId = 0;
  for (const s of slideshows) {
    for (let i = 0; i < s.queue.length; i++) {
      const item = s.queue[i];
      mediaStore.put({
        id: globalId++,
        slideshowId: s.id,
        queueIndex: i,
        blob: item.file,
        name: item.file.name,
        mimeType: item.file.type,
        type: item.type,
        seconds: item.seconds,
        useFullLength: item.useFullLength,
        muted: item.muted,
        hideHeader: item.hideHeader,
      });
    }
  }

  return new Promise((resolve, reject) => {
    tx.oncomplete = resolve;
    tx.onerror = () => reject(tx.error);
  });
}

async function loadFromDB() {
  try {
    const db = await openDB();

    // Check if we have new multi-slideshow data
    const metaTx = db.transaction(SLIDESHOWS_STORE, 'readonly');
    const metaStore = metaTx.objectStore(SLIDESHOWS_STORE);
    const allMeta = await new Promise((resolve, reject) => {
      const req = metaStore.getAll();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });

    const metaMap = {};
    allMeta.forEach(m => metaMap[m.key] = m.value);

    if (metaMap.slideshows) {
      // New format: multi-slideshow
      const metaList = metaMap.slideshows;
      activeSlideshowIndex = metaMap.activeSlideshowIndex || 0;
      nextSlideshowId = metaMap.nextSlideshowId || 1;

      // Load all media
      const mediaTx = db.transaction(STORE_NAME, 'readonly');
      const mediaStore = mediaTx.objectStore(STORE_NAME);
      const allMedia = await new Promise((resolve, reject) => {
        const req = mediaStore.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });

      // Group media by slideshowId
      const mediaBySlideshow = {};
      for (const entry of allMedia) {
        if (!mediaBySlideshow[entry.slideshowId]) mediaBySlideshow[entry.slideshowId] = [];
        mediaBySlideshow[entry.slideshowId].push(entry);
      }

      slideshows = [];
      const durPending = [];
      for (const meta of metaList) {
        const s = { id: meta.id, name: meta.name, queue: [], settings: meta.settings };
        const entries = (mediaBySlideshow[meta.id] || []).sort((a, b) => a.queueIndex - b.queueIndex);
        for (const entry of entries) {
          const file = new File([entry.blob], entry.name, { type: entry.mimeType });
          const objectURL = URL.createObjectURL(file);
          const item = {
            file, objectURL, type: entry.type,
            seconds: entry.seconds, useFullLength: entry.useFullLength,
            muted: entry.muted || false, hideHeader: entry.hideHeader || false,
            duration: null,
          };
          s.queue.push(item);
          if (item.type === 'video') {
            durPending.push(getVideoDuration(objectURL).then(dur => {
              item.duration = dur;
              if (item.seconds > dur) item.seconds = dur;
            }));
          }
        }
        slideshows.push(s);
      }
      if (durPending.length > 0) await Promise.all(durPending);
    } else {
      // Migration from v1: check old settings/media stores
      const settingsTx = db.transaction(SETTINGS_STORE, 'readonly');
      const settingsStore = settingsTx.objectStore(SETTINGS_STORE);
      const allSettings = await new Promise((resolve, reject) => {
        const req = settingsStore.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
      const settings = {};
      allSettings.forEach(s => settings[s.key] = s.value);

      const mediaTx = db.transaction(STORE_NAME, 'readonly');
      const mediaStore = mediaTx.objectStore(STORE_NAME);
      const allItems = await new Promise((resolve, reject) => {
        const req = mediaStore.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
      allItems.sort((a, b) => a.id - b.id);

      const s = createSlideshow('Slideshow 1');
      if (settings.headerText !== undefined) s.settings.headerText = settings.headerText;
      if (settings.startDate !== undefined) s.settings.startDate = settings.startDate;
      if (settings.startHour !== undefined) s.settings.startHour = settings.startHour;
      if (settings.startMinute !== undefined) s.settings.startMinute = settings.startMinute;
      if (settings.startPeriod !== undefined) s.settings.startPeriod = settings.startPeriod;
      if (settings.defaultSeconds !== undefined) s.settings.defaultSeconds = settings.defaultSeconds;
      if (settings.loopQueue !== undefined) s.settings.loopQueue = settings.loopQueue;
      if (settings.countdownEndText !== undefined) s.settings.countdownEndText = settings.countdownEndText;

      const durPending = [];
      for (const entry of allItems) {
        const file = new File([entry.blob], entry.name, { type: entry.mimeType });
        const objectURL = URL.createObjectURL(file);
        const item = {
          file, objectURL, type: entry.type,
          seconds: entry.seconds, useFullLength: entry.useFullLength,
          muted: entry.muted || false, hideHeader: entry.hideHeader || false,
          duration: null,
        };
        s.queue.push(item);
        if (item.type === 'video') {
          durPending.push(getVideoDuration(objectURL).then(dur => {
            item.duration = dur;
            if (item.seconds > dur) item.seconds = dur;
          }));
        }
      }
      if (durPending.length > 0) await Promise.all(durPending);
      activeSlideshowIndex = 0;
    }

    // Ensure at least one slideshow exists
    if (slideshows.length === 0) {
      createSlideshow('Slideshow 1');
      activeSlideshowIndex = 0;
    }

    // Load active slideshow into UI
    loadSlideshowToUI(getActiveSlideshow());
    renderQueue();
    renderTabs();
  } catch (e) {
    console.warn('Could not restore from IndexedDB:', e);
    if (slideshows.length === 0) {
      createSlideshow('Slideshow 1');
      activeSlideshowIndex = 0;
    }
    renderQueue();
    renderTabs();
  }
}

async function clearDB() {
  const db = await openDB();
  const tx = db.transaction([STORE_NAME, SETTINGS_STORE, SLIDESHOWS_STORE], 'readwrite');
  tx.objectStore(STORE_NAME).clear();
  tx.objectStore(SETTINGS_STORE).clear();
  tx.objectStore(SLIDESHOWS_STORE).clear();
}

// ── DOM refs ──
const controlDeck   = document.getElementById('controlDeck');
const presentation  = document.getElementById('presentation');
const dropZone      = document.getElementById('dropZone');
const fileInput     = document.getElementById('fileInput');
const queueList     = document.getElementById('queueList');
const emptyMsg      = document.getElementById('emptyMsg');
const goBtn         = document.getElementById('goBtn');
const clearBtn      = document.getElementById('clearBtn');
const headerTextIn  = document.getElementById('headerText');
const countdownPreview = document.getElementById('countdownPreview');
const defaultSecIn  = document.getElementById('defaultSeconds');
const countdownEndTextIn = document.getElementById('countdownEndText');
const loopCheckbox  = document.getElementById('loopQueue');
const liveHeaderText = document.getElementById('liveHeaderText');
const liveCountdown  = document.getElementById('liveCountdown');
const stage          = document.getElementById('stage');
const exitBtn        = document.getElementById('exitBtn');
const tabBar         = document.getElementById('tabBar');

// ── Tab Bar Rendering ──
function renderTabs() {
  tabBar.innerHTML = '';
  slideshows.forEach((s, i) => {
    const tab = document.createElement('div');
    tab.className = 'tab' + (i === activeSlideshowIndex ? ' active' : '');

    const nameSpan = document.createElement('span');
    nameSpan.textContent = s.name;
    tab.appendChild(nameSpan);

    tab.addEventListener('click', (e) => {
      if (e.target.classList.contains('tab-close')) return;
      switchSlideshow(i);
    });

    // Double-click to rename
    tab.addEventListener('dblclick', (e) => {
      if (e.target.classList.contains('tab-close')) return;
      const newName = prompt('Rename slideshow:', s.name);
      if (newName && newName.trim()) {
        s.name = newName.trim();
        renderTabs();
        saveToDB();
      }
    });

    // Close button (only if more than 1 slideshow)
    if (slideshows.length > 1) {
      const closeBtn = document.createElement('button');
      closeBtn.className = 'tab-close';
      closeBtn.textContent = '\u00d7';
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteSlideshow(i);
      });
      tab.appendChild(closeBtn);
    }

    tabBar.appendChild(tab);
  });

  // Add "+" button
  const addBtn = document.createElement('button');
  addBtn.className = 'tab-add';
  addBtn.textContent = '+';
  addBtn.title = 'Create new slideshow';
  addBtn.addEventListener('click', () => {
    const defaultName = 'Slideshow ' + (slideshows.length + 1);
    const name = prompt('New slideshow name:', defaultName);
    if (name === null) return;
    saveUIToActiveSlideshow();
    createSlideshow(name.trim() || defaultName);
    activeSlideshowIndex = slideshows.length - 1;
    const s = getActiveSlideshow();
    // Set today's date as default for new slideshow
    const today = new Date();
    s.settings.startDate = today.getFullYear() + '-' +
      String(today.getMonth() + 1).padStart(2, '0') + '-' +
      String(today.getDate()).padStart(2, '0');
    loadSlideshowToUI(s);
    renderQueue();
    renderTabs();
    saveToDB();
  });
  tabBar.appendChild(addBtn);
}

// ── Helpers ──
function isVideo(file) {
  return file.type.startsWith('video/');
}

function parseTime() {
  const hourVal = document.getElementById('startHour').value;
  const minuteVal = document.getElementById('startMinute').value;
  const period = document.getElementById('startPeriod').value;

  if (!hourVal) return null;

  let hours = parseInt(hourVal, 10);
  const minutes = parseInt(minuteVal, 10);
  if (period === 'AM' && hours === 12) hours = 0;
  else if (period === 'PM' && hours !== 12) hours += 12;

  const dateVal = document.getElementById('startDate').value;
  let target;
  if (dateVal) {
    const [y, m, d] = dateVal.split('-').map(Number);
    target = new Date(y, m - 1, d, hours, minutes, 0, 0);
  } else {
    const now = new Date();
    target = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0, 0);
    if (target <= now) target.setDate(target.getDate() + 1);
  }
  return target;
}

function formatCountdown(ms) {
  if (ms <= 0) return null;
  const totalSec = Math.ceil(ms / 1000);
  const days = Math.floor(totalSec / 86400);
  const h  = Math.floor((totalSec % 86400) / 3600);
  const m  = Math.floor((totalSec % 3600) / 60);
  const s  = totalSec % 60;
  const hms = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  if (days > 0) return `${days}d ${hms}`;
  return hms;
}

// ── Rendering the queue list ──
function renderQueue() {
  const queue = getActiveSlideshow().queue;
  queueList.innerHTML = '';
  emptyMsg.style.display = queue.length ? 'none' : 'block';
  goBtn.disabled = queue.length === 0;

  // Update total loop duration
  const totalDurationEl = document.getElementById('totalDuration');
  if (queue.length > 0) {
    const totalSec = queue.reduce((sum, item) => sum + (item.seconds || 0), 0);
    const mins = Math.floor(totalSec / 60);
    const secs = totalSec % 60;
    totalDurationEl.textContent = 'Total loop: ' + (mins > 0 ? mins + 'm ' : '') + secs + 's';
  } else {
    totalDurationEl.textContent = '';
  }

  queue.forEach((item, i) => {
    const li = document.createElement('li');
    li.draggable = true;
    li.dataset.index = i;

    // Thumbnail
    if (item.type === 'image') {
      const img = document.createElement('img');
      img.className = 'thumb';
      img.src = item.objectURL;
      li.appendChild(img);
    } else {
      const vid = document.createElement('video');
      vid.className = 'thumb';
      vid.src = item.objectURL;
      vid.muted = true;
      vid.preload = 'metadata';
      li.appendChild(vid);
    }

    // File name
    const nameSpan = document.createElement('span');
    nameSpan.className = 'file-name';
    nameSpan.textContent = item.file.name;
    li.appendChild(nameSpan);

    // Type badge
    const badge = document.createElement('span');
    badge.className = 'file-type ' + item.type;
    badge.textContent = item.type;
    li.appendChild(badge);

    if (item.type === 'video') {
      const durLabel = document.createElement('span');
      durLabel.className = 'timer-label';
      durLabel.textContent = item.duration ? item.duration + 's' : '...';
      li.appendChild(durLabel);

      const muteLabel = document.createElement('label');
      muteLabel.className = 'use-full-length';
      const muteCheck = document.createElement('input');
      muteCheck.type = 'checkbox';
      muteCheck.checked = item.muted;
      muteCheck.addEventListener('change', () => {
        item.muted = muteCheck.checked;
        saveToDB();
      });
      muteLabel.appendChild(muteCheck);
      muteLabel.appendChild(document.createTextNode(' Mute audio'));
      li.appendChild(muteLabel);
    } else {
      const timerLabel = document.createElement('span');
      timerLabel.className = 'timer-label';
      timerLabel.textContent = 'sec:';
      li.appendChild(timerLabel);

      const timerInput = document.createElement('input');
      timerInput.className = 'timer-input';
      timerInput.type = 'number';
      timerInput.min = 1;
      timerInput.max = 600;
      timerInput.value = item.seconds;
      timerInput.addEventListener('change', () => {
        item.seconds = Math.max(1, parseInt(timerInput.value, 10) || 10);
        timerInput.value = item.seconds;
        saveToDB();
      });
      li.appendChild(timerInput);
    }

    // Hide header toggle
    const hideHeaderLabel = document.createElement('label');
    hideHeaderLabel.className = 'use-full-length';
    const hideHeaderCheck = document.createElement('input');
    hideHeaderCheck.type = 'checkbox';
    hideHeaderCheck.checked = item.hideHeader;
    hideHeaderCheck.addEventListener('change', () => {
      item.hideHeader = hideHeaderCheck.checked;
      saveToDB();
    });
    hideHeaderLabel.appendChild(hideHeaderCheck);
    hideHeaderLabel.appendChild(document.createTextNode(' Hide countdown'));
    li.appendChild(hideHeaderLabel);

    // Remove
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.textContent = '\u00d7';
    removeBtn.addEventListener('click', () => {
      if (!confirm('Are you sure you want to delete this slide?')) return;
      URL.revokeObjectURL(item.objectURL);
      queue.splice(i, 1);
      renderQueue();
      saveToDB();
    });
    li.appendChild(removeBtn);

    // Drag-and-drop reorder
    li.addEventListener('dragstart', (e) => {
      li.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', i);
    });
    li.addEventListener('dragend', () => li.classList.remove('dragging'));
    li.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    li.addEventListener('drop', (e) => {
      e.preventDefault();
      const from = parseInt(e.dataTransfer.getData('text/plain'), 10);
      const to = i;
      if (from !== to) {
        const [moved] = queue.splice(from, 1);
        queue.splice(to, 0, moved);
        renderQueue();
        saveToDB();
      }
    });

    queueList.appendChild(li);
  });
}

// ── Adding files ──
function addFiles(files) {
  const queue = getActiveSlideshow().queue;
  const defaultSec = parseInt(defaultSecIn.value, 10) || 10;
  const pending = [];
  for (const file of files) {
    if (!file.type.startsWith('image/') && !file.type.startsWith('video/')) continue;
    const type = file.type.startsWith('video/') ? 'video' : 'image';
    const objectURL = URL.createObjectURL(file);
    const item = {
      file,
      objectURL,
      type,
      seconds: defaultSec,
      useFullLength: type === 'video',
      muted: false,
      hideHeader: false,
      duration: null,
    };
    queue.push(item);
    if (type === 'video') {
      pending.push(getVideoDuration(objectURL).then(dur => {
        item.duration = dur;
        item.seconds = dur;
        item.useFullLength = true;
      }));
    }
  }
  if (pending.length > 0) {
    Promise.all(pending).then(() => { renderQueue(); saveToDB(); });
  } else {
    renderQueue();
    saveToDB();
  }
}

function getVideoDuration(url) {
  return new Promise(resolve => {
    const v = document.createElement('video');
    v.preload = 'metadata';
    v.src = url;
    v.addEventListener('loadedmetadata', () => {
      resolve(Math.floor(v.duration));
    });
    v.addEventListener('error', () => resolve(10));
  });
}

// Drop zone events
dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  addFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', () => {
  addFiles(fileInput.files);
  fileInput.value = '';
});

// Clear all
clearBtn.addEventListener('click', () => {
  const queue = getActiveSlideshow().queue;
  if (queue.length === 0) return;
  if (!confirm('Are you sure you want to clear all slides?')) return;
  queue.forEach(item => URL.revokeObjectURL(item.objectURL));
  queue.length = 0;
  renderQueue();
  saveToDB();
});

// ── Presentation ──
function startPresentation() {
  const queue = getActiveSlideshow().queue;
  if (queue.length === 0) return;
  running = true;
  currentIndex = 0;
  controlDeck.style.display = 'none';
  presentation.style.display = 'block';

  if ('wakeLock' in navigator) {
    navigator.wakeLock.request('screen').then(lock => { wakeLock = lock; }).catch(() => {});
  }

  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen().catch(() => {});
  }

  showItem(currentIndex);
}

function stopPresentation() {
  running = false;
  clearTimeout(slideshowTimeout);

  if (wakeLock) { wakeLock.release().catch(() => {}); wakeLock = null; }

  stage.innerHTML = '';

  presentation.style.display = 'none';
  controlDeck.style.display = 'block';

  if (document.fullscreenElement) {
    document.exitFullscreen().catch(() => {});
  }
}

function fitEndText() {
  const el = liveCountdown;
  const maxW = window.innerWidth * 0.9;
  const maxH = window.innerHeight * 0.8;
  let size = window.innerWidth * 0.12;
  el.style.fontSize = size + 'px';
  while (size > 16 && (el.scrollWidth > maxW || el.scrollHeight > maxH)) {
    size -= 2;
    el.style.fontSize = size + 'px';
  }
}

function startCountdown() {
  function tick() {
    const target = parseTime();
    const customText = headerTextIn.value.trim();

    if (!target) {
      liveHeaderText.textContent = customText || '';
      liveCountdown.textContent = '';
      liveCountdown.classList.remove('done');
      liveCountdown.style.fontSize = '';
      document.getElementById('headerOverlay').classList.remove('takeover');
      stage.style.display = '';
      countdownPreview.textContent = 'Set a date & time above to see the countdown';
      return;
    }
    const diff = target - Date.now();
    if (diff <= 0) {
      liveHeaderText.textContent = '';
      const endText = countdownEndTextIn.value.trim() || 'Bidding is LIVE!';
      liveCountdown.textContent = endText;
      liveCountdown.classList.add('done');
      countdownPreview.textContent = endText;
      document.getElementById('headerOverlay').classList.add('takeover');
      stage.style.display = 'none';
      fitEndText();
      return;
    }
    const formatted = formatCountdown(diff);
    liveCountdown.classList.remove('done');
    liveCountdown.style.fontSize = '';
    document.getElementById('headerOverlay').classList.remove('takeover');
    stage.style.display = '';
    liveHeaderText.textContent = customText || '';
    liveCountdown.textContent = formatted;
    countdownPreview.textContent = (customText ? customText + '  ' : '') + formatted;
  }
  tick();
  countdownInterval = setInterval(tick, 500);
}

function showItem(index) {
  if (!running) return;
  const queue = getActiveSlideshow().queue;
  if (index >= queue.length) {
    if (loopCheckbox.checked) {
      currentIndex = 0;
      showItem(0);
    }
    return;
  }

  const item = queue[index];

  const existing = stage.querySelector('.visible');
  if (existing) {
    existing.classList.remove('visible');
    setTimeout(() => showItemActual(item, index), 800);
  } else {
    showItemActual(item, index);
  }
}

function showItemActual(item, index) {
  if (!running) return;
  stage.innerHTML = '';

  const overlay = document.getElementById('headerOverlay');
  overlay.style.opacity = item.hideHeader ? '0' : '1';

  if (item.type === 'image') {
    const img = document.createElement('img');
    img.src = item.objectURL;
    stage.appendChild(img);
    const fadeIn = () => requestAnimationFrame(() => requestAnimationFrame(() => img.classList.add('visible')));
    if (img.complete) fadeIn(); else img.addEventListener('load', fadeIn);

    slideshowTimeout = setTimeout(() => {
      currentIndex = index + 1;
      showItem(currentIndex);
    }, item.seconds * 1000 + 100);
  } else {
    const vid = document.createElement('video');
    vid.src = item.objectURL;
    vid.autoplay = true;
    vid.playsInline = true;
    vid.muted = item.muted;
    stage.appendChild(vid);
    requestAnimationFrame(() => requestAnimationFrame(() => vid.classList.add('visible')));

    if (item.useFullLength) {
      vid.addEventListener('ended', () => {
        currentIndex = index + 1;
        showItem(currentIndex);
      });
    } else {
      slideshowTimeout = setTimeout(() => {
        vid.pause();
        currentIndex = index + 1;
        showItem(currentIndex);
      }, item.seconds * 1000 + 100);
    }
  }
}

// ── Controls ──
goBtn.addEventListener('click', startPresentation);
exitBtn.addEventListener('click', stopPresentation);
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && running) stopPresentation();
});

// Init — default the date picker to today
const today = new Date();
document.getElementById('startDate').value =
  today.getFullYear() + '-' +
  String(today.getMonth() + 1).padStart(2, '0') + '-' +
  String(today.getDate()).padStart(2, '0');

// Save settings when any control changes
[headerTextIn, document.getElementById('startDate'), document.getElementById('startHour'),
 document.getElementById('startMinute'), document.getElementById('startPeriod'),
 defaultSecIn, loopCheckbox].forEach(el => {
  el.addEventListener('change', () => saveToDB());
});
headerTextIn.addEventListener('input', () => saveToDB());
countdownEndTextIn.addEventListener('input', () => saveToDB());

// ── Export / Import ──
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const importFileInput = document.getElementById('importFileInput');

function fileToDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(file);
  });
}

function dataURLtoFile(dataURL, name) {
  const [header, b64] = dataURL.split(',');
  const mime = header.match(/:(.*?);/)[1];
  const binary = atob(b64);
  const arr = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) arr[i] = binary.charCodeAt(i);
  return new File([arr], name, { type: mime });
}

exportBtn.addEventListener('click', async () => {
  saveUIToActiveSlideshow();
  const s = getActiveSlideshow();
  exportBtn.textContent = 'Exporting...';
  exportBtn.disabled = true;
  try {
    const slides = [];
    for (const item of s.queue) {
      const dataURL = await fileToDataURL(item.file);
      slides.push({
        name: item.file.name,
        mimeType: item.file.type,
        type: item.type,
        seconds: item.seconds,
        useFullLength: item.useFullLength,
        muted: item.muted,
        hideHeader: item.hideHeader,
        dataURL,
      });
    }
    const payload = {
      version: 1,
      name: s.name,
      settings: { ...s.settings },
      slides,
    };
    const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = s.name + '.json';
    a.click();
    URL.revokeObjectURL(url);
  } catch (e) {
    alert('Export failed: ' + e.message);
  } finally {
    exportBtn.textContent = 'Export Slideshow';
    exportBtn.disabled = false;
  }
});

importBtn.addEventListener('click', () => importFileInput.click());

importFileInput.addEventListener('change', async () => {
  const jsonFile = importFileInput.files[0];
  if (!jsonFile) return;
  importFileInput.value = '';
  importBtn.textContent = 'Importing...';
  importBtn.disabled = true;
  try {
    const text = await jsonFile.text();
    const data = JSON.parse(text);
    if (!data.version || data.version !== 1) {
      alert('Unsupported file format or version.');
      return;
    }
    // Determine name
    let name = data.name || 'Imported Slideshow';
    if (slideshows.some(s => s.name === name)) name += ' (imported)';

    saveUIToActiveSlideshow();
    const newShow = createSlideshow(name);
    if (data.settings) Object.assign(newShow.settings, data.settings);

    const durPending = [];
    for (const slide of (data.slides || [])) {
      const file = dataURLtoFile(slide.dataURL, slide.name);
      const objectURL = URL.createObjectURL(file);
      const item = {
        file, objectURL,
        type: slide.type,
        seconds: slide.seconds,
        useFullLength: slide.useFullLength,
        muted: slide.muted || false,
        hideHeader: slide.hideHeader || false,
        duration: null,
      };
      newShow.queue.push(item);
      if (item.type === 'video') {
        durPending.push(getVideoDuration(objectURL).then(dur => {
          item.duration = dur;
          if (item.seconds > dur) item.seconds = dur;
        }));
      }
    }
    if (durPending.length > 0) await Promise.all(durPending);

    activeSlideshowIndex = slideshows.length - 1;
    loadSlideshowToUI(newShow);
    renderQueue();
    renderTabs();
    saveToDB();
  } catch (e) {
    alert('Import failed: ' + e.message);
  } finally {
    importBtn.textContent = 'Import Slideshow';
    importBtn.disabled = false;
  }
});

// ── Cloud Sync (Cloudflare R2) ──
const WORKER_URL = 'https://auctionslides-api.forecastmatt.workers.dev';
let cloudSlideshowId = null;
let cloudLastSyncedMeta = null; // JSON string snapshot of metadata at last sync

const cloudSaveBtn = document.getElementById('cloudSaveBtn');
const cloudLoadBtn = document.getElementById('cloudLoadBtn');
const cloudStatus = document.getElementById('cloudStatus');
const cloudLinkRow = document.getElementById('cloudLinkRow');
const cloudLink = document.getElementById('cloudLink');
const copyLinkBtn = document.getElementById('copyLinkBtn');

function setCloudStatus(text, cls) {
  cloudStatus.textContent = text;
  cloudStatus.className = 'cloud-status' + (cls ? ' ' + cls : '');
}

function generateCloudId() {
  return Math.random().toString(36).substring(2, 10) + Date.now().toString(36);
}

function buildMetaSnapshot(s) {
  return JSON.stringify({
    name: s.name,
    settings: s.settings,
    slides: s.queue.map(item => ({
      filename: item.file.name,
      mimeType: item.file.type,
      type: item.type,
      seconds: item.seconds,
      useFullLength: item.useFullLength,
      muted: item.muted,
      hideHeader: item.hideHeader,
    })),
  });
}

async function uploadToCloud() {
  saveUIToActiveSlideshow();
  const s = getActiveSlideshow();

  if (cloudLastSyncedMeta && buildMetaSnapshot(s) === cloudLastSyncedMeta) {
    setCloudStatus('No changes to save', 'done');
    return;
  }

  cloudSaveBtn.disabled = true;
  setCloudStatus('Uploading...', 'syncing');

  try {
    if (!cloudSlideshowId) cloudSlideshowId = generateCloudId();
    const prefix = cloudSlideshowId + '/';

    // Delete old files for this slideshow
    setCloudStatus('Cleaning old files...', 'syncing');
    const listResp = await fetch(WORKER_URL + '/_list?prefix=' + encodeURIComponent(prefix));
    const oldFiles = await listResp.json();
    for (const f of oldFiles) {
      await fetch(WORKER_URL + '/' + f.key, { method: 'DELETE' });
    }

    // Upload each media file
    for (let i = 0; i < s.queue.length; i++) {
      const item = s.queue[i];
      const key = prefix + String(i).padStart(4, '0') + '_' + item.file.name;
      setCloudStatus('Uploading file ' + (i + 1) + '/' + s.queue.length + '...', 'syncing');

      const resp = await fetch(WORKER_URL + '/' + key, {
        method: 'PUT',
        headers: { 'Content-Type': item.file.type },
        body: item.file,
      });
      if (!resp.ok) throw new Error('Upload failed for ' + item.file.name);
    }

    // Upload metadata as JSON
    const metadata = {
      name: s.name,
      settings: s.settings,
      slides: s.queue.map((item, i) => ({
        key: prefix + String(i).padStart(4, '0') + '_' + item.file.name,
        filename: item.file.name,
        mimeType: item.file.type,
        type: item.type,
        seconds: item.seconds,
        useFullLength: item.useFullLength,
        muted: item.muted,
        hideHeader: item.hideHeader,
      })),
    };
    const metaResp = await fetch(WORKER_URL + '/' + prefix + '_meta.json', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(metadata),
    });
    if (!metaResp.ok) throw new Error('Failed to save metadata');

    // Show link
    const url = window.location.origin + window.location.pathname + '?id=' + cloudSlideshowId;
    cloudLink.textContent = url;
    cloudLinkRow.style.display = '';
    cloudLoadBtn.style.display = '';
    history.replaceState(null, '', '?id=' + cloudSlideshowId);

    cloudLastSyncedMeta = buildMetaSnapshot(s);
    setCloudStatus('Saved to cloud', 'done');
  } catch (e) {
    setCloudStatus('Upload failed: ' + e.message, 'error');
  } finally {
    cloudSaveBtn.disabled = false;
  }
}

async function loadFromCloud(id) {
  setCloudStatus('Loading from cloud...', 'syncing');
  cloudSaveBtn.disabled = true;

  try {
    const prefix = id + '/';

    // Fetch metadata
    const metaResp = await fetch(WORKER_URL + '/' + prefix + '_meta.json');
    if (!metaResp.ok) {
      setCloudStatus('Slideshow not found in cloud', 'error');
      cloudSaveBtn.disabled = false;
      return;
    }
    const metadata = await metaResp.json();

    // Check if cloud version is the same as what we already have
    const cloudSnap = JSON.stringify({
      name: metadata.name,
      settings: metadata.settings,
      slides: (metadata.slides || []).map(sl => ({
        filename: sl.filename,
        mimeType: sl.mimeType,
        type: sl.type,
        seconds: sl.seconds,
        useFullLength: sl.useFullLength,
        muted: sl.muted,
        hideHeader: sl.hideHeader,
      })),
    });
    if (cloudLastSyncedMeta && cloudSnap === cloudLastSyncedMeta) {
      setCloudStatus('Already up to date', 'done');
      cloudSaveBtn.disabled = false;
      return;
    }

    cloudSlideshowId = id;

    const s = getActiveSlideshow();
    s.queue.forEach(item => URL.revokeObjectURL(item.objectURL));
    s.queue.length = 0;
    s.name = metadata.name || s.name;
    if (metadata.settings) Object.assign(s.settings, metadata.settings);

    const durPending = [];
    for (let i = 0; i < metadata.slides.length; i++) {
      const slide = metadata.slides[i];
      setCloudStatus('Downloading file ' + (i + 1) + '/' + metadata.slides.length + '...', 'syncing');

      const fileResp = await fetch(WORKER_URL + '/' + slide.key);
      if (!fileResp.ok) throw new Error('Failed to download ' + slide.filename);
      const blob = await fileResp.blob();
      const file = new File([blob], slide.filename, { type: slide.mimeType || blob.type });
      const objectURL = URL.createObjectURL(file);

      const item = {
        file, objectURL,
        type: slide.type,
        seconds: slide.seconds,
        useFullLength: slide.useFullLength,
        muted: slide.muted || false,
        hideHeader: slide.hideHeader || false,
        duration: null,
      };
      s.queue.push(item);
      if (item.type === 'video') {
        durPending.push(getVideoDuration(objectURL).then(dur => {
          item.duration = dur;
          if (item.seconds > dur) item.seconds = dur;
        }));
      }
    }
    if (durPending.length > 0) await Promise.all(durPending);

    loadSlideshowToUI(s);
    renderQueue();
    renderTabs();
    saveToDB();

    const url = window.location.origin + window.location.pathname + '?id=' + cloudSlideshowId;
    cloudLink.textContent = url;
    cloudLinkRow.style.display = '';
    cloudLoadBtn.style.display = '';
    history.replaceState(null, '', '?id=' + cloudSlideshowId);

    cloudLastSyncedMeta = buildMetaSnapshot(s);
    setCloudStatus('Loaded from cloud', 'done');
  } catch (e) {
    setCloudStatus('Load failed: ' + e.message, 'error');
  } finally {
    cloudSaveBtn.disabled = false;
  }
}

function checkUrlForCloudId() {
  const params = new URLSearchParams(window.location.search);
  const id = params.get('id');
  if (id) loadFromCloud(id);
}

cloudSaveBtn.addEventListener('click', uploadToCloud);
cloudLoadBtn.addEventListener('click', () => {
  if (cloudSlideshowId) loadFromCloud(cloudSlideshowId);
});
copyLinkBtn.addEventListener('click', () => {
  navigator.clipboard.writeText(cloudLink.textContent).then(() => {
    copyLinkBtn.textContent = 'Copied!';
    setTimeout(() => { copyLinkBtn.textContent = 'Copy Link'; }, 2000);
  });
});

// Load saved state from IndexedDB, then start countdown and check for cloud ID
loadFromDB().then(() => {
  startCountdown();
  checkUrlForCloudId();
});

</script>
</body>
</html>
